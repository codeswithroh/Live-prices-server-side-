const signalR = require("@microsoft/signalr")
const signalRMsgPack = require("@microsoft/signalr-protocol-msgpack")

var hubConnection = null
var json = false
let scheme = "http"
var conTimeout
var IsSubsSegment = false;
var IsSubscribeAll = false;
var IsSubscribeTrade = false;
var IsSubscribeBestAndRefs = false;
var IsSubscribeGreeks = false;
var SubscribeAllList = [];
var SubscribeTradeList = [];
var SubscribeBestAndRefsList = [];
var SubscribeGreeksList = [];

//#region connection initialize
const initialize = async function (apiKey, apiHost = "localhost:5011", protoScheme = "http") {

  if (!apiKey) {
    return
  }

  scheme = protoScheme
  if (!hubConnection || hubConnection.state === signalR.HubConnectionState.Disconnected)
    await buildHub(apiKey, apiHost)
}

const buildHub = async function (apiKey, host) {
  let urlBase = `${scheme}://${host}/api/fda/apidata/stream?api_token=`
  let url = `${urlBase}${encodeURIComponent(apiKey)}`
  // console.log(url)
  hubConnection = new signalR.HubConnectionBuilder()
    .withUrl(encodeURI(url))
    //.configureLogging(signalR.LogLevel.Trace)
    //.withAutomaticReconnect()
    .withAutomaticReconnect({
      nextRetryDelayInMilliseconds: context => {
        //console.log(context.retryReason)
        return 2000
      }
    })
    .withHubProtocol(json ? new signalR.JsonHubProtocol() : new signalRMsgPack.MessagePackHubProtocol())
    .build()
  // hubConnection.serverTimeoutInMilliseconds = 40000
  //hubConnection.keepAliveIntervalInMilliseconds = 1000 * 60 * 2
  hubConnection.onclose(error => {
    // console.error('Connection closed due to error.', error)
    if (onClosedCallback)
      onClosedCallback(error)
  })

  hubConnection.onreconnecting(error => {
    // console.log('Connection lost due to error. Reconnecting.', error)
  })

  hubConnection.onreconnected(connectionId => {
    if (IsSubsSegment) {
      subscribeSegments(false);
      console.log("On reconnect => subscribeSegments done");
    }
    if (IsSubscribeAll) {
      subscribeAll(SubscribeAllList)
      SubscribeAllList = [];
      console.log("On reconnect => subscribeAll done");
    }
    if (IsSubscribeTrade) {
      subscribeTrade(SubscribeTradeList);
      SubscribeTradeList = [];
      console.log("On reconnect => subscribeTrade done");
    }
    if (IsSubscribeBestAndRefs) {
      subscribeBestAndRefs(SubscribeBestAndRefsList);
      SubscribeBestAndRefsList = [];
      console.log("On reconnect => subscribeBestAndRefs done");
    }
    if (IsSubscribeGreeks) {
      subscribeGreeks(SubscribeGreeksList)
      SubscribeGreeksList = [];
    }
    // console.assert(hubConnection.state === signalR.HubConnectionState.Connected)
    // onReconnectedCallback()
  })

  await startConnection()

  if (hubConnection.state === signalR.HubConnectionState.Connected) {
    // console.log('Connection established...')
    if (onConnectedCallback)
      onConnectedCallback()
  }
}

const startConnection = async function () {
  try {

    if (hubConnection.state === signalR.HubConnectionState.Connected)
      return

    await hubConnection.start()
    registerHandlerCallback()

    hubConnection.on("Shutdown", async msg => {
      console.log(msg)
      await hubConnection.stop()
    })

  } catch (err) {
    // console.assert(connection.state === signalR.HubConnectionState.Disconnected)
    console.error('Connection error: ', err, 'Auto retry in 5s')
    return
    conTimeout = setTimeout(() => startConnection(), 5000)
  }
}
//#endregion

//#region disconnect
const disconnect = async function () {
  clearTimeout(conTimeout)
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    return
  }
  await hubConnection.stop()
}
//#endregion

//#region Master

const getMaster = async function () {

  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => connection closed`)
    return
  }

  let ed = await hubConnection.invoke("MasterData")
  if (!ed)
    return []
  let d = ed.map(item => {
    return new Master(item)
  })
  return d
}

//#endregion

//#region connection callbacks

var onClosedCallback = null
// var onReconnectedCallback = null
var onConnectedCallback = null

// const onReconnected = function (callback) {
//   onReconnectedCallback = callback
// }

const onConnected = function (callback) {
  onConnectedCallback = callback
}

const onClosed = function (callback) {
  onClosedCallback = callback
}
//#endregion

//#region register handlers and callback

var tradeCallback = null
var tradeSnapshotCallback = null
var bestCallback = null
var refsCallback = null
var refsSnapshotCallback = null
var tradeWithDelayAndMultiply = {}
var greeksCallback = null
var greekSnapshotCallback = null

function registerHandlerCallback() {
  tradeHandler()
  bestHandler()
  refsHandler()
  greeksHandler()
}

function refsHandler() {
  hubConnection.on("f", function (srefsMsg) {
    if (!refsCallback)
      return
    refsCallback(new Refs(srefsMsg))
  })
  hubConnection.on("_r", async function (refsMsg) {
    if (!refsSnapshotCallback)
      return
    await refsSnapshotCallback(new RefsSnapshot(refsMsg))
  })
}

function bestHandler() {
  hubConnection.on("_b", function (bestMsg) {
    if (!bestCallback)
      return
    bestCallback(new Best(bestMsg))
  })

  hubConnection.on("b", function (bestMsg) {
    if (!bestCallback)
      return
    bestCallback(new Best(bestMsg))
  })
}

var sendTradeWithDelay = false
var timeout = setInterval(() => {
  if (!tradeWithDelayAndMultiply.callback
    || !tradeWithDelayAndMultiply.delayInSeconds
    || tradeWithDelayAndMultiply.delayInSeconds <= 0) {
    clearInterval(timeout)
    sendTradeWithDelay = true // to send continue updates
    return
  }
  console.log("in timer")
  sendTradeWithDelay = true
}, tradeWithDelayAndMultiply.delayInSeconds * 1000)

function tradeHandler() {
  hubConnection.on("_t", function (tradeMsg) {
    if (tradeSnapshotCallback)
      tradeSnapshotCallback(new Trade(tradeMsg))
    // if (tradeWithDelayAndMultiply.callback) {
    //   UpdateTradeWithMultiplyDelay(tradeMsg)
    // }
  })
  hubConnection.on("t", function (tradeMsg) {
    if (tradeCallback)
      tradeCallback(new Trade(tradeMsg))

    if (tradeWithDelayAndMultiply.callback) {
      UpdateTradeWithMultiplyDelay(tradeMsg)
    }
  })
}

function greeksHandler() {
  hubConnection.on("_G", function (greekMsg) {
    if (!greekSnapshotCallback)
      return
    greekSnapshotCallback(new Greeks(greekMsg))
  })

  hubConnection.on("G", function (greekMsg) {
    if (!greeksCallback)
      return
    greeksCallback(new Greeks(greekMsg))
  })
}

async function UpdateTradeWithMultiplyDelay(tradeMsg) {
  if (!sendTradeWithDelay)
    return
  //console.log("on trade snap with multiply")
  var trd = new Trade(tradeMsg)
  trd.price = trd.price * tradeWithDelayAndMultiply.multiplier
  sendTradeWithDelay = false
  await tradeWithDelayAndMultiply.callback(trd)
}


//#endregion

//#region Models
class Master {
  constructor(msg) {
    this.xid = msg[0]
    this.tkr = msg[1]
    this.atkr = msg[2]
    this.ctkr = msg[3]
    this.exp = new Date(msg[4] + "Z")
    this.utkr = msg[5]
    this.inst = msg[6]
    this.a3tkr = msg[7]
    this.sp = msg[8]
    this.tk = msg[9]
  }
}
class Trade {
  constructor(msg) {
    this.id = msg[0]
    this.kind = String.fromCharCode(msg[8])
    this.ticker = msg[1]
    this.segmentId = msg[2]

    let dt1980 = new Date(1980, 0, 1)
    dt1980.setSeconds(msg[3])
    this.time = new Date(dt1980 + "Z")

    this.price = msg[4]
    this.qty = msg[5]
    this.volume = msg[6]
    this.oi = msg[7]
  }
}

class Best {
  constructor(msg) {
    this.kind = String.fromCharCode(msg[2])
    this.ticker = msg[0]
    this.segmentId = msg[1]
    this.bidPrice = msg[3]
    this.bidQty = msg[4]
    this.askPrice = msg[5]
    this.askQty = msg[6]
    let dt1980 = new Date(1980, 0, 1)
    dt1980.setSeconds(msg[7])
    this.time = new Date(dt1980 + "Z")
  }
}

class RefsSnapshot {
  constructor(msg) {
    this.kind = String.fromCharCode(msg[0])
    this.ticker = msg[1]
    this.segmentId = msg[2]
    this.open = msg[3]
    this.close = msg[4]
    this.high = msg[5]
    this.low = msg[6]
    this.avg = msg[7]
    this.oi = msg[8]
    this.upperBand = msg[9]
    this.lowerBand = msg[10]
    this.poi = msg[11]
  }
}

class Refs {
  constructor(msg) {
    this.kind = String.fromCharCode(msg[0])
    this.ticker = msg[1]
    this.segmentId = msg[2]
    this.price = msg[3]
  }
}

class Greeks {
  constructor(msg) {
    this.kind = String.fromCharCode(msg[0])
    this.token = msg[1]
    this.ticker = msg[2]
    this.iv = msg[3]
    this.delta = msg[4]
    this.theta = msg[5]
    this.vega = msg[6]
    this.gamma = msg[7]
    this.ivvwap = msg[8]
    this.vanna = msg[9]
    this.charm = msg[10]
    this.speed = msg[11]
    this.zomma = msg[12]
    this.color = msg[13]
    this.volga = msg[14]
    this.veta = msg[15]
    this.tgr = msg[16]
    this.tv = msg[17]
    this.dtr = msg[18]
    this.highiv = msg[19]
    this.lowiv = msg[20]
    this.twapiv = msg[21]
    this.timestamp = msg[22]

  }
}

//#endregion

//#region Eod

const getEod = async function (ticker, startDate, endDate) {
  if (!ticker || !startDate || !endDate) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }

  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => connection closed`)
    return
  }

  let ed = await hubConnection.invoke("Eod", ticker, startDate, endDate)
  return toEodJsonArray(ticker, ed)
  //console.log(eod)
}

const getEodContract = async function (underlyingTicker, startDate, endDate, contractExpiry) {
  if (!underlyingTicker || !startDate || !endDate) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => connection closed`)
    return
  }

  let ed = await hubConnection.invoke("EodContract", underlyingTicker, startDate, endDate, contractExpiry)
  return toEodJsonArray(ticker, ed)
}
/*
/**
 * 
 * @param ticker symbol name to get data eg. NIFTY-1, BANKNIFTY-1, TCS
 * @param startDate start date, format: yyyyMMdd eg. 20201012  
 * @param endDate end date, format: yyyyMMdd eg. 20201112
 * @param resolution time resolution in minutes. default: 5 minutes
 */
const getIntraEod = async function (ticker = "", startDate = "", endDate = "", resolution = "5") {
  if (!ticker || !startDate || !endDate) {
    console.log('getIntraEod => not enough arguments')
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log('getIntraEod => connection closed')
    return
  }

  let ed = await hubConnection.invoke("IEod", ticker, startDate, endDate, resolution)
  return toEodJsonArray(ticker, ed)
}

const getIntraEodContract = async function (underlyingTicker, startDate, endDate, contractExpiry, resolution = "5") {
  if (!underlyingTicker || !startDate || !endDate) {
    console.log('getIntraEodContract => not enough arguments')
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => connection closed`)
    return
  }

  let ed = await hubConnection.invoke("IEodContract", underlyingTicker, startDate, endDate, contractExpiry, resolution)
  return toEodJsonArray(ticker, ed)
}

const toEodJsonArray = function (ticker, arr) {
  let d = arr.map(item => {
    return {
      //"tkr": ticker,
      "td": new Date(item[1] + "Z"),
      "op": parseFloat(item[2]),
      "hp": parseFloat(item[3]),
      "lp": parseFloat(item[4]),
      "cp": parseFloat(item[5]),
      "vol": item[6],
      "oi": item[7]
    }
  })
  return d
}

const getBackTicks = async function (ticker, lastDateTime) {
  if (!ticker || !lastDateTime) {
    console.log(`getBackTicks => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`getBackTicks => connection closed`)
    return
  }
  let td = await hubConnection.invoke("TicksHistory", ticker, lastDateTime)
  var md = td.map(tick => {
    let dt1980 = new Date(1980, 0, 1)
    dt1980.setSeconds(tick[1])
    return {
      "td": new Date(dt1980 + "Z"),
      "pr": parseFloat(tick[2]),
      "vol": tick[3],
      "oi": tick[4]
    }
  })
  return md
}

//#endregion

//#region stream subscription methods

const subscribeTrade = async function (tickerList) {
  if (!tickerList) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} =>Connection is not established or closed`)
    return
  }
  await hubConnection.invoke("Ticks", tickerList)
  IsSubscribeTrade = true
  for (var i = 0; i < tickerList.length; i++) {
    SubscribeTradeList.push(tickerList[i])
  }
}

const subscribeBestAndRefs = async function (tickerList) {
  if (!tickerList) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }

  await hubConnection.invoke("Others", tickerList)

  IsSubscribeBestAndRefs = true
  for (var i = 0; i < tickerList.length; i++) {
    SubscribeBestAndRefsList.push(tickerList[i])
  }
}

const subscribeAll = async function (tickerList) {
  if (!tickerList) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }

  var res = await hubConnection.invoke("SubscribeAll", tickerList)

  IsSubscribeAll = true;
  for (var i = 0; i < tickerList.length; i++) {
    SubscribeAllList.push(tickerList[i])
  }
  return res
}

const subscribeOptionChain = async function (underlyingSpotName, expiryDate) {
  if (!underlyingSpotName || !expiryDate) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }
  var res = await hubConnection.invoke("SubscribeChain", underlyingSpotName, expiryDate)
  return res
}

const subscribeOptionChainRange = async function (underlyingSpotName, expiryDate, numberOfStrikes) {
  if (!underlyingSpotName || !expiryDate || numberOfStrikes <= 0) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }
  var res = await hubConnection.invoke("SubscribeChainRange", underlyingSpotName, expiryDate, numberOfStrikes)
  return res
}


const unsubscribeOptionChain = async function (underlyingSpotName, expiryDate) {
  if (!underlyingSpotName || !expiryDate) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }
  var res = await hubConnection.invoke("UnsubscribeChain", underlyingSpotName, expiryDate)
  return res
}

const subscribeSegments = async function (needSnapshot = false) {
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }

  var res = await hubConnection.invoke("SubscribeSegments", needSnapshot)
  // console.log(res)
  IsSubsSegment = true;
  return res
}

const subscribeGreeks = async function (tickerList) {
  var tickerlist = tickerList.filter(element => {
    if (element != '') return element;
  })

  if ((!tickerList) || (tickerlist.length === 0)) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }

  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }

  var res = await hubConnection.invoke("SubscribeGreeks", tickerlist)
  IsSubscribeGreeks = true;

  for (var i = 0; i < tickerList.length; i++) {
    SubscribeGreeksList.push(tickerList[i])
  }
  return res

}
const unsubscribeGreeks = async function (tickerList) {
  if (!tickerList) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }

  await hubConnection.invoke("UnsubscribeGreeks", tickerList)
}
//UnsubscribeGreeks

//#endregion

//#region Unsubscribe
const unsubscribeAll = async function (tickerList) {
  if (!tickerList) {
    console.log(`${arguments.callee.name} => not enough arguments`)
    return
  }
  if (!hubConnection || hubConnection.state !== signalR.HubConnectionState.Connected) {
    console.log(`${arguments.callee.name} => Connection is not established or closed`)
    return
  }

  await hubConnection.invoke("UnsubscribeAll", tickerList)
  if (IsSubscribeAll) {
    for (var i = 0; i < tickerList.length; i++) {
      let index = SubscribeAllList.indexOf(tickerList[i])
      if (index > -1) {
        SubscribeAllList.splice(index, 1);
      }
    }
    //console.log(SubscribeAllList);
  }

  if (IsSubscribeTrade) {
    for (var i = 0; i < tickerList.length; i++) {
      let index = SubscribeTradeList.indexOf(tickerList[i])
      if (index > -1) {
        SubscribeTradeList.splice(index, 1);
      }
    }
    console.log(SubscribeTradeList);
  }
  if (IsSubscribeBestAndRefs) {
    for (var i = 0; i < tickerList.length; i++) {
      let index = SubscribeBestAndRefsList.indexOf(tickerList[i])
      if (index > -1) {
        SubscribeBestAndRefsList.splice(index, 1);
      }
    }
  }

}

//#endregion

//#region Stream callback methods

/**
 * Trade data callback
 * @param tradeCallback A callback method to receive trade data
 */
const onTrade = function (callback) {
  tradeCallback = callback
}

const onTradeSnapshot = function (callback) {
  tradeSnapshotCallback = callback
}

const onTradeWithDelayAndMultiply = function (callback, multiplier, delayInSeconds) {
  tradeWithDelayAndMultiply = { callback, multiplier, delayInSeconds }
}


const onBest = function (callback) {
  bestCallback = callback
}

/**
 * 
 * @param callback A callback method to receive ANY of reference datas like o, h, l, c, avg and oi
 * whenever there is change on those data
 */
const onRefs = function (callback) {
  refsCallback = callback
}

/**
 * 
 * @param callback A callback method to receive ALL of reference datas like o, h, l, c, avg and oi as snapshot
 */
const onRefsSnapshot = async function (callback) {
  refsSnapshotCallback = callback
}

/**
 * 
 * @param callback A callback method to receive ALL of Greek datas 
 *  */
const onGreeks = async function (callback) {
  greeksCallback = callback
}

const onGreekSnapshot = function (callback) {
  greekSnapshotCallback = callback
}
//#endregion

const func = function (abc) {
  console.log(`${arguments.callee.name} => not enough arguments`)
}

module.exports = { initialize, getMaster, disconnect }
module.exports.history = { getEod, getEodContract, getIntraEod, getIntraEodContract, getBackTicks }
module.exports.stream = {
  subscribeTrade, subscribeBestAndRefs, subscribeAll, unsubscribeAll, subscribeSegments,
  subscribeGreeks, unsubscribeGreeks,
  subscribeOptionChain, subscribeOptionChainRange, unsubscribeOptionChain
}
module.exports.callbacks = { onTrade, onTradeSnapshot, onBest, onRefs, onRefsSnapshot, onConnected, onClosed, onTradeWithDelayAndMultiply, onGreeks, onGreekSnapshot }
module.exports.models = { Master, Trade, Best, Refs, RefsSnapshot }

